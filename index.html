<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Moto 3D – Flat track + bots</title>
<link rel="icon" href="data:,">
<style>
  :root { --bg:#0b0e14; --hud:rgba(0,0,0,.35); --lime:#9be870; }
  html,body{margin:0;height:100%;background:var(--bg);color:#e8ecf1;font-family:system-ui;overscroll-behavior:none}
  canvas{display:block;touch-action:none}
  #hud{position:fixed;left:12px;top:12px;background:var(--hud);padding:8px 10px;border-radius:8px;backdrop-filter:blur(4px);line-height:1.25}
  #hud b{color:var(--lime)}
  #tips{position:fixed;right:12px;top:12px;opacity:.85}
  #pause{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;
         padding:14px 18px;background:rgba(0,0,0,.55);border-radius:12px;display:none}

  /* Pads tactiles */
  .pad{position:fixed;bottom:22px;width:42vw;max-width:320px;height:42vw;max-height:320px;
       border:2px solid rgba(255,255,255,.28);border-radius:50%;opacity:.28;touch-action:none}
  #padL{left:22px} #padR{right:22px}
  .stick{position:absolute;left:50%;top:50%;width:30%;height:30%;
         transform:translate(-50%,-50%);border:2px solid rgba(255,255,255,.6);border-radius:50%}
  @media (pointer:fine){ .pad{display:none} }
</style>
</head>
<body>
  <div id="hud">
    Vitesse: <b id="spd">0</b> km/h<br/>
    Tour: <b id="lap">0</b> / 3<br/>
    Temps: <b id="time">00:00.000</b><br/>
    Meilleur: <b id="best">--:--.---</b>
  </div>
  <div id="tips">Z/Q/S/D ou flèches · Espace=frein · N=Nitro · P=Pause · R=Reset · Gamepad OK</div>
  <div id="pause">PAUSE</div>
  <div id="padL" class="pad"><div id="stickL" class="stick"></div></div>
  <div id="padR" class="pad"><div id="stickR" class="stick"></div></div>

  <!-- Import map pour three -->
  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>

  <script type="module">
  import * as THREE from "three";
  import * as CANNON from "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js";

  /* ========= Helpers ========= */
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const formatTime = (ms)=>{
    const m=Math.floor(ms/60000); ms-=m*60000;
    const s=Math.floor(ms/1000);
    const r=Math.floor(ms%1000);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(r).padStart(3,'0')}`;
  };

  /* ========= Renderer & Scene ========= */
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
  renderer.domElement.tabIndex = 0; // capter le clavier
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0e14);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 3000);
  camera.position.set(0,6,12);

  scene.add(new THREE.HemisphereLight(0xbcd4ff,0x091018,.85));
  const sun=new THREE.DirectionalLight(0xffffff,.9); sun.position.set(40,60,30); scene.add(sun);

  // Sol lointain
  const floor=new THREE.Mesh(
    new THREE.PlaneGeometry(4000,4000),
    new THREE.MeshStandardMaterial({color:0x0e141b,roughness:1})
  );
  floor.rotation.x=-Math.PI/2; floor.position.y=-2; floor.receiveShadow=true; scene.add(floor);

  /* ========= Piste plate (ovale) ========= */
  function buildTrack(){
    const pts=[], segs=700, RX=220, RZ=140;
    for(let i=0;i<segs;i++){
      const t=i/segs*2*Math.PI;
      pts.push(new THREE.Vector3(Math.cos(t)*RX, 0, Math.sin(t)*RZ));
    }
    const curve=new THREE.CatmullRomCurve3(pts,true,"catmullrom",0.5);

    const ROAD_HALF=6.8, n=900;
    const positions=[], uvs=[], indices=[];
    for(let i=0;i<n;i++){
      const t=i/(n-1), p=curve.getPointAt(t);
      const tan=curve.getTangentAt(t).normalize();
      const left=new THREE.Vector3(-tan.z,0,tan.x).normalize();
      const a=p.clone().addScaledVector(left,-ROAD_HALF);
      const b=p.clone().addScaledVector(left, ROAD_HALF);
      positions.push(a.x,a.y,a.z, b.x,b.y,b.z);
      uvs.push(0,t*45, 1,t*45);
      if(i<n-1){ const base=i*2; indices.push(base,base+1,base+2, base+1,base+3,base+2); }
    }
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));
    geo.setAttribute('uv',new THREE.Float32BufferAttribute(uvs,2));
    geo.setIndex(indices); geo.computeVertexNormals();

    const road=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0x3a475a,roughness:.95}));
    const shoulder=new THREE.Mesh(geo.clone(),new THREE.MeshStandardMaterial({color:0x202734,roughness:1}));
    shoulder.scale.set(1.35,1,1.35); shoulder.position.y=-0.02;

    const line=new THREE.Group(), dashGeo=new THREE.BoxGeometry(.28,.03,1.6), dashMat=new THREE.MeshStandardMaterial({color:0xbfd2ff});
    for(let i=0;i<280;i++){
      const t=i/280,p=curve.getPointAt(t),tan=curve.getTangentAt(t);
      const m=new THREE.Mesh(dashGeo,dashMat);
      m.position.copy(p).add(new THREE.Vector3(0,0.02,0));
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(tan.x,0,tan.z).normalize());
      line.add(m);
    }

    function lateralInfo(x,z){
      const P=new THREE.Vector3(x,0,z);
      let bestD=Infinity,bp=null,bn=null;
      const steps=256;
      for(let i=0;i<=steps;i++){
        const t=i/steps,p=curve.getPointAt(t);
        const d=P.distanceToSquared(p);
        if(d<bestD){
          bestD=d; bp=p;
          const tan=curve.getTangentAt(t).normalize();
          bn=new THREE.Vector3(-tan.z,0,tan.x).normalize();
        }
      }
      const to=new THREE.Vector3().subVectors(P,bp);
      const lat=to.dot(bn);
      return {lat,p:bp,n:bn};
    }

    return {curve,ROAD_HALF,road,shoulder,line,lateralInfo};
  }
  const track=buildTrack();
  scene.add(track.shoulder, track.road, track.line);

  /* ========= Physique (Cannon-es) ========= */
  const world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
  world.solver.iterations=12;

  // Colliders ruban (yaw uniquement, piste plate)
  const SEG_BODIES=180, THICK=0.25;
  for(let i=0;i<SEG_BODIES;i++){
    const t0=i/SEG_BODIES, t1=(i+1)/SEG_BODIES;
    const p0=track.curve.getPointAt(t0), p1=track.curve.getPointAt(t1);
    const dx=p1.x-p0.x, dz=p1.z-p0.z;
    const len=Math.max(0.0001, Math.hypot(dx,dz));
    const body=new CANNON.Body({mass:0, shape:new CANNON.Box(new CANNON.Vec3(track.ROAD_HALF, THICK/2, len/2))});
    body.position.set((p0.x+p1.x)/2, 0, (p0.z+p1.z)/2);
    const yaw=Math.atan2(dx,dz);
    body.quaternion.setFromEuler(0,yaw,0,"XYZ");
    world.addBody(body);
  }

  /* ========= Véhicule ========= */
  function makeVehicle(startT){
    const p=track.curve.getPointAt(startT);
    const tan=track.curve.getTangentAt(startT);
    const yaw=Math.atan2(tan.x,tan.z);

    const chassis=new CANNON.Body({
      mass:170,
      shape:new CANNON.Box(new CANNON.Vec3(.6,.32,1.05)),
      position:new CANNON.Vec3(p.x, .9, p.z)
    });
    chassis.quaternion.setFromEuler(0, yaw, 0, "XYZ");
    world.addBody(chassis);

    const vehicle=new CANNON.RaycastVehicle({chassisBody:chassis});
    const wopt={radius:.36, directionLocal:new CANNON.Vec3(0,-1,0),
      suspensionRestLength:.28, suspensionStiffness:42, dampingRelaxation:2.4, dampingCompression:4.6,
      frictionSlip:2.3, axleLocal:new CANNON.Vec3(1,0,0), maxSuspensionForce:1e4, maxSuspensionTravel:.36,
      customSlidingRotationalSpeed:-30, useCustomSlidingRotationalSpeed:true
    };
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3(0,0, .95), radius:.34}); // avant (0)
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3(0,0,-.95), radius:.37}); // arrière (1)
    vehicle.addToWorld(world);
    return {chassis,vehicle};
  }

  function makeMotoMesh(color=0x4caf50){
    const root=new THREE.Group();
    const main=new THREE.MeshStandardMaterial({color,metalness:.05,roughness:.6});
    const dark=new THREE.MeshStandardMaterial({color:0x222,metalness:.1,roughness:.8});
    const light=new THREE.MeshStandardMaterial({color:0xf5f6f8,metalness:.05,roughness:.5});
    const frame=new THREE.Mesh(new THREE.BoxGeometry(1.3,.38,2.1), light); frame.position.y=.4;
    const seat =new THREE.Mesh(new THREE.BoxGeometry(1.0,.18,1.0), main); seat.position.set(0,.62,-.1);
    const hood =new THREE.Mesh(new THREE.BoxGeometry(.8,.22,.7),  main); hood.position.set(0,.58,.6);
    const wG=new THREE.TorusGeometry(.36,.08,10,20), wM=dark;
    const wF=new THREE.Mesh(wG,wM); wF.rotation.x=Math.PI/2; wF.position.set(0,.38,.95);
    const wR=wF.clone(); wR.position.z=-.95; wR.scale.set(1.03,1.03,1.03);
    const bar=new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.65,8), light); bar.rotation.z=Math.PI/2; bar.position.set(0,.92,.45);
    const plate=new THREE.Mesh(new THREE.BoxGeometry(.52,.42,.08), light); plate.position.set(0,.85,.85);
    const fender=new THREE.Mesh(new THREE.BoxGeometry(.9,.08,.5), main); fender.position.set(0,.52,.95);
    const tail=new THREE.Mesh(new THREE.BoxGeometry(.9,.06,.5), main); tail.position.set(0,.52,-.95);
    root.add(frame,seat,hood,wF,wR,bar,plate,fender,tail);
    root.position.y=0.2; return root;
  }

  /* ========= Joueur + bots ========= */
  const player = makeVehicle(0.02);
  const motoPlayer = makeMotoMesh(0x4caf50); scene.add(motoPlayer);

  const bots=[], BOT_COLORS=[0xffd400,0x2196f3,0xf44336];
  for(let i=0;i<3;i++){
    const t=(0.78 - i*0.05 + 1)%1;
    const b=makeVehicle(t);
    const m=makeMotoMesh(BOT_COLORS[i%BOT_COLORS.length]);
    scene.add(m); bots.push({ ...b, vis:m, t });
  }

  /* ========= Entrées (clavier + pads) ========= */
  const input={steer:0, throttle:0, brake:0, hand:false, nitro:false, paused:false};
  const keys={};

  function setKey(e,isDown){
    const k=e.code||e.key;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    keys[k]=isDown;
  }
  addEventListener('keydown',e=>{
    setKey(e,true);
    if(e.code==='KeyP'){ input.paused=!input.paused; document.getElementById('pause').style.display=input.paused?'block':'none'; }
    if(e.code==='KeyR'){ resetOnTrack(player.chassis); }
  }, {passive:false});
  addEventListener('keyup',e=>setKey(e,false), {passive:false});
  renderer.domElement.addEventListener('click',()=>renderer.domElement.focus());

  // Pads (empêche le scroll avec passive:false)
  function bindPad(pad,stick,cb){
    let act=false,id=null,cx=0,cy=0,r=0;
    const rect=()=>pad.getBoundingClientRect();
    const pos=t=>({x:t.clientX-rect().left, y:t.clientY-rect().top});
    const start=t=>{ if(act) return; act=true; id=t.pointerId; pad.setPointerCapture(id);
      const rc=rect(); cx=rc.width/2; cy=rc.height/2; r=rc.width/2; move(t); t.preventDefault(); };
    const move=t=>{ if(!act||t.pointerId!==id) return; const p=pos(t); let dx=p.x-cx, dy=p.y-cy;
      const m=Math.hypot(dx,dy); if(m>r){ dx*=r/m; dy*=r/m; }
      stick.style.left=(50+dx/r*50)+'%'; stick.style.top=(50+dy/r*50)+'%'; cb(dx/r,dy/r); t.preventDefault(); };
    const end=t=>{ if(!act||t.pointerId!==id) return; act=false; try{pad.releasePointerCapture(id)}catch{}
      stick.style.left='50%'; stick.style.top='50%'; cb(0,0); };
    pad.addEventListener('pointerdown',start,{passive:false});
    pad.addEventListener('pointermove', move,{passive:false});
    pad.addEventListener('pointerup',   end ,{passive:false});
    pad.addEventListener('pointercancel',end);
  }
  bindPad(document.getElementById('padL'), document.getElementById('stickL'),
    (dx,dy)=>{ input.steer = clamp(dx,-1,1); });
  bindPad(document.getElementById('padR'), document.getElementById('stickR'),
    (dx,dy)=>{ input.throttle = clamp(-dy,0,1); input.brake = clamp(dy>0?dy:0,0,1); });

  function resetOnTrack(body){
    const p=body.position; let bestD=Infinity,bestT=0;
    const STEPS=360;
    for(let i=0;i<=STEPS;i++){
      const t=i/STEPS, c=track.curve.getPointAt(t);
      const d=(c.x-p.x)**2 + (c.z-p.z)**2; if(d<bestD){bestD=d; bestT=t;}
    }
    const c=track.curve.getPointAt(bestT), tan=track.curve.getTangentAt(bestT);
    const yaw=Math.atan2(tan.x,tan.z);
    body.position.set(c.x, .9, c.z);
    body.velocity.set(0,0,0); body.angularVelocity.set(0,0,0);
    body.quaternion.setFromEuler(0,yaw,0,'XYZ');
  }

  /* ========= HUD & cam ========= */
  const spdEl=document.getElementById('spd'), lapEl=document.getElementById('lap'), timeEl=document.getElementById('time'), bestEl=document.getElementById('best');
  let laps=0, best=null, lapStart=performance.now();

  function chase(mesh){
    const fwd=new THREE.Vector3(0,0,1).applyQuaternion(mesh.quaternion);
    const up=new THREE.Vector3(0,1,0);
    const look=mesh.position.clone().add(fwd.clone().multiplyScalar(4)).add(up.clone().multiplyScalar(1.6));
    const pos =mesh.position.clone().add(fwd.clone().multiplyScalar(-10)).add(up.clone().multiplyScalar(3.8));
    camera.position.lerp(pos,.12); camera.lookAt(look);
  }

  /* ========= Boucle ========= */
  let last=performance.now();
  function tick(now){
    requestAnimationFrame(tick);
    const dt=Math.min(1/60,(now-last)/1000); last=now;
    if(input.paused){ renderer.render(scene,camera); return; }

    // Clavier -> input (pads gardent leur valeur)
    const up = !!(keys['ArrowUp'] || keys['KeyW'] || keys['KeyZ']);
    const dn = !!(keys['ArrowDown'] || keys['KeyS']);
    const lf = !!(keys['ArrowLeft'] || keys['KeyA'] || keys['KeyQ']);
    const rt = !!(keys['ArrowRight'] || keys['KeyD']);
    input.throttle = Math.max(input.throttle, up?1:0);
    input.brake    = Math.max(input.brake,    dn?1:0);
    input.steer   += (((lf?-1:0)+(rt?1:0)) - input.steer) * 0.25;
    input.hand     = !!keys['Space'];
    input.nitro    = !!keys['KeyN'];

    const MAX_ENGINE = input.nitro ? 2800 : 2000;
    const MAX_STEER  = 0.52;
    const BRAKE      = 52, H_BRAKE = 90;

    // Joueur
    {
      const pos=player.chassis.position;
      const {lat}=track.lateralInfo(pos.x,pos.z);
      const onTrack=Math.abs(lat)<=track.ROAD_HALF*1.05;
      const grip=onTrack?1:0.6;
window.applyPlayerDrive = function(MAX_ENGINE, MAX_STEER, BRAKE, onTrack, grip) {
  player.vehicle.setSteeringValue(clamp(input.steer, -1, 1) * MAX_STEER * grip, 0);
  player.vehicle.setSteeringValue(0, 1);

  player.vehicle.setBrake(0, 0);
  player.vehicle.setBrake(0, 1);

  const engine = (input.throttle * MAX_ENGINE) * (onTrack ? 1 : 0.6);
  console.log("Throttle:", input.throttle, "Engine force:", engine);

  player.vehicle.applyEngineForce(1 * engine, 1); // Try forcing sign to 1
  player.vehicle.applyEngineForce(0, 0);

  const br = (input.brake ? BRAKE : 0) + (input.hand ? 90 : 0);
  player.vehicle.setBrake(br, 0);
  player.vehicle.setBrake(br, 1);
    };
    }

    // Bots
    bots.forEach(b=>{
      b.t=(b.t+dt*0.055)%1;
      const dir=track.curve.getTangentAt(b.t);
      const desiredYaw=Math.atan2(dir.x,dir.z);

      const q=b.chassis.quaternion;
      const ys=Math.atan2(2*(q.w*q.y+q.x*q.z),1-2*(q.y*q.y+q.z*q.z));
      const angDiff=Math.atan2(Math.sin(desiredYaw-ys),Math.cos(desiredYaw-ys));
      const steer=clamp(angDiff*1.1,-0.5,0.5);

      b.vehicle.setSteeringValue(steer,0); b.vehicle.setSteeringValue(0,1);
      b.vehicle.applyEngineForce(1700,1);
      b.vehicle.applyEngineForce(0,0);
      b.vehicle.setBrake(0,0); b.vehicle.setBrake(0,1);
    });

    world.step(1/60,dt);

    // Sync meshes
    motoPlayer.position.copy(player.chassis.position);
    motoPlayer.quaternion.copy(player.chassis.quaternion);
    bots.forEach(b=>{ b.vis.position.copy(b.chassis.position); b.vis.quaternion.copy(b.chassis.quaternion); });

    chase(motoPlayer);
    spdEl.textContent=Math.round(player.chassis.velocity.length()*3.6);
    timeEl.textContent=formatTime(now-lapStart);

    renderer.render(scene,camera);

    // relâchement progressif si le clavier n’appuie plus
    input.throttle = up ? 1 : input.throttle*0.98;
    input.brake    = dn ? 1 : input.brake*0.98;
  }
  requestAnimationFrame(tick);

  addEventListener('resize',()=>{
    renderer.setSize(innerWidth,innerHeight);
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });
  </script>
</body>
</html>
