<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Minimal Car – Clean Build</title>
<link rel="icon" href="data:,">
<style>
  :root{--bg:#0b0e14;--hud:rgba(0,0,0,.35);--lime:#9be870}
  html,body{margin:0;height:100%;background:var(--bg);color:#e8ecf1;font-family:system-ui;overscroll-behavior:none}
  canvas{display:block;touch-action:none}
  #hud{position:fixed;left:12px;top:12px;background:var(--hud);padding:8px 10px;border-radius:8px;backdrop-filter:blur(4px);line-height:1.25}
  #hud b{color:var(--lime)}
  #tips{position:fixed;right:12px;top:12px;opacity:.85}
  #pause{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;padding:14px 18px;background:rgba(0,0,0,.55);border-radius:12px;display:none}
</style>
</head>
<body>
  <div id="hud">
    Vitesse: <b id="spd">0</b> km/h ·
    Temps: <b id="time">00:00.000</b>
  </div>
  <div id="tips">Z/↑ accélérer · S/↓ freiner · Q/A gauche · D droite · Espace frein à main · N nitro · R reset · P pause</div>
  <div id="pause">PAUSE</div>

  <!-- Import map for THREE -->
  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>

  <script type="module">
  import * as THREE from "three";
  import * as CANNON from "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js";

  // ---------- utils ----------
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const fmt=ms=>{const m=Math.floor(ms/60000); ms-=m*60000; const s=Math.floor(ms/1000); const r=Math.floor(ms%1000);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(r).padStart(3,'0')}`;};

  // ---------- renderer / scene ----------
  const renderer=new THREE.WebGLRenderer({antialias:true, powerPreference:"high-performance"});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
  renderer.domElement.tabIndex=0;
  document.body.appendChild(renderer.domElement);

  const scene=new THREE.Scene();
  scene.background=new THREE.Color(0x0b0e14);

  const camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 2000);
  camera.position.set(0,5,11);

  scene.add(new THREE.HemisphereLight(0xbcd4ff,0x091018,.9));
  const sun=new THREE.DirectionalLight(0xffffff,.5); sun.position.set(40,60,30); scene.add(sun);

  // sol visuel
  const floor=new THREE.Mesh(
    new THREE.PlaneGeometry(2000,2000),
    new THREE.MeshStandardMaterial({color:0x0e141b,roughness:1})
  );
  floor.rotation.x = -Math.PI/2; floor.position.y = -2; scene.add(floor);

  // ---------- piste ovale (visuel) ----------
  function buildTrack(){
    const pts=[], segs=320, RX=120, RZ=80;
    for(let i=0;i<segs;i++){
      const t=i/segs*2*Math.PI;
      pts.push(new THREE.Vector3(Math.cos(t)*RX, 0, Math.sin(t)*RZ));
    }
    const curve=new THREE.CatmullRomCurve3(pts,true,"catmullrom",0.5);

    const ROAD_HALF=5.5, n=420;
    const pos=[], idx=[];
    for(let i=0;i<n;i++){
      const t=i/(n-1), p=curve.getPointAt(t);
      const tan=curve.getTangentAt(t).normalize();
      const left=new THREE.Vector3(-tan.z,0,tan.x).normalize();
      const a=p.clone().addScaledVector(left,-ROAD_HALF);
      const b=p.clone().addScaledVector(left, ROAD_HALF);
      pos.push(a.x,0,a.z, b.x,0,b.z);
      if(i<n-1){ const base=i*2; idx.push(base,base+1,base+2, base+1,base+3,base+2); }
    }
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
    geo.setIndex(idx); geo.computeVertexNormals();
    const road=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0x354155,roughness:.98}));

    // ligne médiane (option légère)
    const line=new THREE.Group();
    const dashG=new THREE.BoxGeometry(.24,.02,1.2);
    const dashM=new THREE.MeshBasicMaterial({color:0xbfd2ff});
    for(let i=0;i<140;i++){
      const t=i/140, p=curve.getPointAt(t), tan=curve.getTangentAt(t);
      const m=new THREE.Mesh(dashG,dashM);
      m.position.set(p.x,0.02,p.z);
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(tan.x,0,tan.z).normalize());
      line.add(m);
    }

    // helper: distance latérale
    function lateralInfo(x,z){
      const P=new THREE.Vector3(x,0,z);
      let bestD=Infinity,bp=null,bn=null;
      const steps=128;
      for(let i=0;i<=steps;i++){
        const t=i/steps, p=curve.getPointAt(t);
        const d=P.distanceToSquared(p);
        if(d<bestD){ bestD=d; bp=p; const tgn=curve.getTangentAt(t).normalize(); bn=new THREE.Vector3(-tgn.z,0,tgn.x).normalize(); }
      }
      const to=new THREE.Vector3().subVectors(P,bp);
      return {lat:to.dot(bn), p:bp, n:bn};
    }

    return {curve, ROAD_HALF, road, line, lateralInfo};
  }
  const track=buildTrack();
  scene.add(track.road, track.line);

  // ---------- physics ----------
  const world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
  world.solver.iterations=10;

  // ruban de boxes (collisions piste pour RaycastVehicle)
  const SEG=120, THICK=0.25;
  for(let i=0;i<SEG;i++){
    const t0=i/SEG, t1=(i+1)/SEG;
    const p0=track.curve.getPointAt(t0), p1=track.curve.getPointAt(t1);
    const dx=p1.x-p0.x, dz=p1.z-p0.z;
    const len=Math.max(0.0001, Math.hypot(dx,dz));
    const body=new CANNON.Body({
      mass:0,
      shape:new CANNON.Box(new CANNON.Vec3(track.ROAD_HALF, THICK/2, len/2))
    });
    body.position.set((p0.x+p1.x)/2, 0, (p0.z+p1.z)/2);
    const yaw=Math.atan2(dx,dz);
    body.quaternion.setFromEuler(0,yaw,0,"XYZ");
    world.addBody(body);
  }

  // ---------- voiture (physique) ----------
  function makeCarVehicle(startT){
    const p=track.curve.getPointAt(startT);
    const tan=track.curve.getTangentAt(startT);
    const yaw=Math.atan2(tan.x,tan.z);

    const chassis=new CANNON.Body({
      mass: 520,
      shape:new CANNON.Box(new CANNON.Vec3(0.9,0.35,1.6)),
      position:new CANNON.Vec3(p.x, 0.66, p.z) // bas pour contact
    });
    chassis.quaternion.setFromEuler(0,yaw,0,"XYZ");
    chassis.angularFactor.set(0,1,0);
    chassis.angularDamping=0.35;
    world.addBody(chassis);

    const vehicle=new CANNON.RaycastVehicle({chassisBody:chassis});
    const wopt={
      radius:0.42,
      directionLocal:new CANNON.Vec3(0,-1,0),
      suspensionRestLength:0.40, suspensionStiffness:44,
      dampingRelaxation:2.4, dampingCompression:4.6,
      frictionSlip:3.0, axleLocal:new CANNON.Vec3(1,0,0),
      maxSuspensionForce:1e4, maxSuspensionTravel:0.44,
      customSlidingRotationalSpeed:-30, useCustomSlidingRotationalSpeed:true
    };
    const TRACK=1.0, WB=2.6;
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3(-TRACK,0, WB/2)});
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3( TRACK,0, WB/2)});
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3(-TRACK,0,-WB/2)});
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3( TRACK,0,-WB/2)});
    vehicle.addToWorld(world);

    return {chassis,vehicle};
  }

  // ---------- voiture (mesh simple) ----------
  function makeCarMesh(color=0xff4d4d){
    const g=new THREE.Group();
    const bodyM = new THREE.MeshStandardMaterial({color, metalness:.05, roughness:.7});
    const darkM = new THREE.MeshStandardMaterial({color:0x222, metalness:.1, roughness:.9});
    const glassM= new THREE.MeshStandardMaterial({color:0x9ed3ff, metalness:.05, roughness:.1, transparent:true, opacity:.8});

    const body  = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.6,3.4), bodyM); body.position.y=0.55; g.add(body);
    const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.6,0.7,1.4), glassM); cabin.position.set(0,1.0,-0.2); g.add(cabin);
    const wheelG= new THREE.CylinderGeometry(0.42,0.42,0.28,12,1,true); wheelG.rotateZ(Math.PI/2);
    function wheel(x,z){ const w=new THREE.Mesh(wheelG, darkM); w.position.set(x,0.42,z); g.add(w); return w; }
    g.userData.wheels=[
      wheel(-1.0,  1.3), wheel( 1.0,  1.3),
      wheel(-1.0, -1.3), wheel( 1.0, -1.3)
    ];
    g.position.y=0.1;
    return g;
  }

  // ---------- joueur ----------
  const player = makeCarVehicle(0.02);
  const carMesh = makeCarMesh(0xff4d4d); scene.add(carMesh);

  // ---------- input ----------
  const input={steer:0, throttle:0, brake:0, hand:false, nitro:false, paused:false};
  const keys={};
  const setKey=(e,d)=>{
    const k=e.code||e.key;
    // empêcher le scroll flèches/espace
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    keys[k]=d;
    if(d){
      if(k==='KeyP'){ input.paused=!input.paused; document.getElementById('pause').style.display=input.paused?'block':'none'; }
      if(k==='KeyR'){ resetOnTrack(player.chassis); }
    }
  };
  window.addEventListener('keydown',e=>setKey(e,true),{passive:false});
  window.addEventListener('keyup',e=>setKey(e,false),{passive:false});
  renderer.domElement.addEventListener('click',()=>renderer.domElement.focus());
  renderer.domElement.focus();

  function resetOnTrack(body){
    const p=body.position; let bestD=Infinity,bestT=0;
    const STEPS=200;
    for(let i=0;i<=STEPS;i++){
      const t=i/STEPS, c=track.curve.getPointAt(t);
      const d=(c.x-p.x)**2 + (c.z-p.z)**2; if(d<bestD){bestD=d; bestT=t;}
    }
    const c=track.curve.getPointAt(bestT), tan=track.curve.getTangentAt(bestT);
    const yaw=Math.atan2(tan.x,tan.z);
    body.position.set(c.x, .66, c.z);
    body.velocity.set(0,0,0); body.angularVelocity.set(0,0,0);
    body.quaternion.setFromEuler(0,yaw,0,'XYZ');
  }

  // ---------- HUD + cam ----------
  const spdEl=document.getElementById('spd'), timeEl=document.getElementById('time');
  const startTime=performance.now();
  function chase(target){
    const fwd=new THREE.Vector3(0,0,1).applyQuaternion(target.quaternion);
    const up =new THREE.Vector3(0,1,0);
    const look=target.position.clone().add(fwd.clone().multiplyScalar(4.5)).add(up.clone().multiplyScalar(1.6));
    const pos =target.position.clone().add(fwd.clone().multiplyScalar(-9.5)).add(up.clone().multiplyScalar(3.2));
    camera.position.lerp(pos,.12); camera.lookAt(look);
  }

  // ---------- boucle ----------
  let last=performance.now();
  function tick(now){
    requestAnimationFrame(tick);
    const dt=Math.min(1/60,(now-last)/1000); last=now;
    if(input.paused){ renderer.render(scene,camera); return; }

    const up = !!(keys['ArrowUp'] || keys['KeyW'] || keys['KeyZ']);
    const dn = !!(keys['ArrowDown'] || keys['KeyS']);
    const lf = !!(keys['ArrowLeft'] || keys['KeyA'] || keys['KeyQ']);
    const rt = !!(keys['ArrowRight'] || keys['KeyD']);

    if(up) input.throttle=1; if(dn) input.brake=1;
    input.steer += (((lf?-1:0)+(rt?1:0)) - input.steer) * 0.25;
    input.hand = !!keys['Space'];
    input.nitro = !!keys['KeyN'];

    const MAX_ENGINE = input.nitro ? 2400 : 1800;
    const MAX_STEER  = 0.5;
    const BRAKE      = 52, H_BRAKE = 90;

    const pos=player.chassis.position;
    const {lat}=track.lateralInfo(pos.x,pos.z);
    const onTrack=Math.abs(lat)<=track.ROAD_HALF*1.05;
    const grip=onTrack?1:0.6;

    const steerVal=clamp(input.steer,-1,1)*MAX_STEER*grip;
    player.vehicle.setSteeringValue(steerVal,0);
    player.vehicle.setSteeringValue(steerVal,1);

    const engine=(input.throttle*MAX_ENGINE)*(onTrack?1:0.65);
    player.vehicle.applyEngineForce(-engine,2);
    player.vehicle.applyEngineForce(-engine,3);

    const brake=(input.brake?BRAKE:0)+(input.hand?H_BRAKE:0);
    for(let i=0;i<4;i++) player.vehicle.setBrake(brake,i);

    world.step(1/60,dt);

    carMesh.position.copy(player.chassis.position);
    carMesh.quaternion.copy(player.chassis.quaternion);
    chase(carMesh);
    spdEl.textContent=Math.round(player.chassis.velocity.length()*3.6);
    timeEl.textContent=fmt(now-startTime);

    renderer.render(scene,camera);

    if(!up) input.throttle*=0.98;
    if(!dn) input.brake*=0.98;
  }
  requestAnimationFrame(tick);

  addEventListener('resize',()=>{
    renderer.setSize(innerWidth,innerHeight);
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });
  </script>
</body>
</html>
