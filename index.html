<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Moto 3D – Flat track</title>
<link rel="icon" href="data:,">
<style>
  :root{--bg:#0b0e14;--hud:rgba(0,0,0,.35);--lime:#9be870}
  html,body{margin:0;height:100%;background:var(--bg);color:#e8ecf1;font-family:system-ui;overscroll-behavior:none}
  canvas{display:block;touch-action:none}
  #hud{position:fixed;left:12px;top:12px;background:var(--hud);padding:8px 10px;border-radius:8px;backdrop-filter:blur(4px);line-height:1.25}
  #hud b{color:var(--lime)}
  #tips{position:fixed;right:12px;top:12px;opacity:.85}
  #pause{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;padding:14px 18px;background:rgba(0,0,0,.55);border-radius:12px;display:none}
  /* Pads mobile */
  .pad{position:fixed;bottom:22px;width:42vw;max-width:320px;height:42vw;max-height:320px;border:2px solid rgba(255,255,255,.28);border-radius:50%;opacity:.28;touch-action:none}
  #padL{left:22px} #padR{right:22px}
  .stick{position:absolute;left:50%;top:50%;width:30%;height:30%;transform:translate(-50%,-50%);border:2px solid rgba(255,255,255,.6);border-radius:50%}
  @media (pointer:fine){.pad{display:none}}
</style>
</head>
<body>
  <div id="hud">
    Vitesse: <b id="spd">0</b> km/h<br>
    Tour: <b id="lap">0</b> / 3<br>
    Temps: <b id="time">00:00.000</b><br>
    Meilleur: <b id="best">--:--.---</b>
  </div>
  <div id="tips">Z/Q/S/D ou flèches · Espace=frein · N=Nitro · P=Pause · R=Reset</div>
  <div id="pause">PAUSE</div>
  <div id="padL" class="pad"><div id="stickL" class="stick"></div></div>
  <div id="padR" class="pad"><div id="stickR" class="stick"></div></div>

  <!-- Import map -->
  <script type="importmap">
  { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>

  <script type="module">
  import * as THREE from "three";
  import * as CANNON from "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js";

  /* ---------- helpers ---------- */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const fmt=ms=>{const m=Math.floor(ms/60000); ms-=m*60000; const s=Math.floor(ms/1000); const r=Math.floor(ms%1000);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(r).padStart(3,'0')}`;};

  /* ---------- renderer & scene ---------- */
  const renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(2, devicePixelRatio||1));
  renderer.domElement.tabIndex=0;
  document.body.appendChild(renderer.domElement);

  const scene=new THREE.Scene();
  scene.background=new THREE.Color(0x0b0e14);

  const camera=new THREE.PerspectiveCamera(60, innerWidth/innerHeight, .1, 3000);
  camera.position.set(0,6,12);

  scene.add(new THREE.HemisphereLight(0xbcd4ff,0x091018,.85));
  const sun=new THREE.DirectionalLight(0xffffff,.9); sun.position.set(40,60,30); scene.add(sun);

  const floor=new THREE.Mesh(
    new THREE.PlaneGeometry(4000,4000),
    new THREE.MeshStandardMaterial({color:0x0e141b,roughness:1})
  );
  floor.rotation.x=-Math.PI/2; floor.position.y=-2; floor.receiveShadow=true; scene.add(floor);

  /* ---------- flat oval track ---------- */
  function buildTrack(){
    const pts=[], segs=700, RX=220, RZ=140;
    for(let i=0;i<segs;i++){
      const t=i/segs*2*Math.PI;
      pts.push(new THREE.Vector3(Math.cos(t)*RX, 0, Math.sin(t)*RZ));
    }
    const curve=new THREE.CatmullRomCurve3(pts,true,"catmullrom",0.5);

    const ROAD_HALF=6.8, n=900;
    const positions=[], uvs=[], indices=[];
    for(let i=0;i<n;i++){
      const t=i/(n-1), p=curve.getPointAt(t);
      const tan=curve.getTangentAt(t).normalize();
      const left=new THREE.Vector3(-tan.z,0,tan.x).normalize();
      const a=p.clone().addScaledVector(left,-ROAD_HALF);
      const b=p.clone().addScaledVector(left, ROAD_HALF);
      positions.push(a.x,a.y,a.z, b.x,b.y,b.z);
      uvs.push(0,t*45, 1,t*45);
      if(i<n-1){ const base=i*2; indices.push(base,base+1,base+2, base+1,base+3,base+2); }
    }
    const geo=new THREE.BufferGeometry();
    geo.setAttribute('position',new THREE.Float32BufferAttribute(positions,3));
    geo.setAttribute('uv',new THREE.Float32BufferAttribute(uvs,2));
    geo.setIndex(indices); geo.computeVertexNormals();

    const road=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0x3a475a,roughness:.95}));
    const shoulder=new THREE.Mesh(geo.clone(),new THREE.MeshStandardMaterial({color:0x202734,roughness:1}));
    shoulder.scale.set(1.35,1,1.35); shoulder.position.y=-0.02;

    const line=new THREE.Group(), dashGeo=new THREE.BoxGeometry(.28,.03,1.6), dashMat=new THREE.MeshStandardMaterial({color:0xbfd2ff});
    for(let i=0;i<280;i++){
      const t=i/280,p=curve.getPointAt(t),tan=curve.getTangentAt(t);
      const m=new THREE.Mesh(dashGeo,dashMat);
      m.position.copy(p).add(new THREE.Vector3(0,0.02,0));
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), new THREE.Vector3(tan.x,0,tan.z).normalize());
      line.add(m);
    }

    function lateralInfo(x,z){
      const P=new THREE.Vector3(x,0,z);
      let bestD=Infinity,bp=null,bn=null;
      const steps=256;
      for(let i=0;i<=steps;i++){
        const t=i/steps,p=curve.getPointAt(t);
        const d=P.distanceToSquared(p);
        if(d<bestD){ bestD=d; bp=p; const tan=curve.getTangentAt(t).normalize(); bn=new THREE.Vector3(-tan.z,0,tan.x).normalize(); }
      }
      const to=new THREE.Vector3().subVectors(P,bp);
      const lat=to.dot(bn);
      return {lat,p:bp,n:bn};
    }

    return {curve,ROAD_HALF,road,shoulder,line,lateralInfo};
  }
  const track=buildTrack();
  scene.add(track.shoulder, track.road, track.line);

  /* ---------- physics ---------- */
  const world=new CANNON.World({gravity:new CANNON.Vec3(0,-9.82,0)});
  world.solver.iterations=12;

  // ribbon of boxes (floor collider)
  const SEG_BODIES=180, THICK=0.25;
  for(let i=0;i<SEG_BODIES;i++){
    const t0=i/SEG_BODIES, t1=(i+1)/SEG_BODIES;
    const p0=track.curve.getPointAt(t0), p1=track.curve.getPointAt(t1);
    const dx=p1.x-p0.x, dz=p1.z-p0.z;
    const len=Math.max(0.0001, Math.hypot(dx,dz));
    const body=new CANNON.Body({mass:0, shape:new CANNON.Box(new CANNON.Vec3(track.ROAD_HALF, THICK/2, len/2))});
    body.position.set((p0.x+p1.x)/2, 0, (p0.z+p1.z)/2);
    const yaw=Math.atan2(dx,dz);
    body.quaternion.setFromEuler(0,yaw,0,"XYZ");
    world.addBody(body);
  }

  /* ---------- vehicle (fake motorbike = 4 close wheels) ---------- */
  function makeVehicle(startT){
    const p=track.curve.getPointAt(startT);
    const tan=track.curve.getTangentAt(startT);
    const yaw=Math.atan2(tan.x,tan.z);

    const chassis=new CANNON.Body({
      mass:170,
      shape:new CANNON.Box(new CANNON.Vec3(.6,.32,1.05)),
      position:new CANNON.Vec3(p.x, .9, p.z)
    });
    chassis.quaternion.setFromEuler(0, yaw, 0, "XYZ");
    world.addBody(chassis);

    const vehicle=new CANNON.RaycastVehicle({chassisBody:chassis});
    const TRACK=0.36, WB=1.90, R_FRONT=.34, R_REAR=.36;
    const wopt={
      radius:R_FRONT,
      directionLocal:new CANNON.Vec3(0,-1,0),
      suspensionRestLength:.28, suspensionStiffness:42,
      dampingRelaxation:2.4, dampingCompression:4.6,
      frictionSlip:2.3, axleLocal:new CANNON.Vec3(1,0,0),
      maxSuspensionForce:1e4, maxSuspensionTravel:.36,
      customSlidingRotationalSpeed:-30, useCustomSlidingRotationalSpeed:true
    };
    // front steer (0,1)
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3(-TRACK/2,0, WB/2), radius:R_FRONT});
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3( TRACK/2,0, WB/2), radius:R_FRONT});
    // rear drive (2,3)
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3(-TRACK/2,0,-WB/2), radius:R_REAR});
    vehicle.addWheel({...wopt, chassisConnectionPointLocal:new CANNON.Vec3( TRACK/2,0,-WB/2), radius:R_REAR});
    vehicle.addToWorld(world);

    chassis.angularFactor.set(0,1,0);  // lock roll/pitch
    chassis.angularDamping=0.3;

    return {chassis,vehicle};
  }

  function makeMotoMesh(color=0x4caf50){
    const root=new THREE.Group();
    const main=new THREE.MeshStandardMaterial({color,metalness:.05,roughness:.6});
    const dark=new THREE.MeshStandardMaterial({color:0x222,metalness:.1,roughness:.8});
    const light=new THREE.MeshStandardMaterial({color:0xf5f6f8,metalness:.05,roughness:.5});
    const frame=new THREE.Mesh(new THREE.BoxGeometry(1.3,.38,2.1), light); frame.position.y=.4;
    const seat =new THREE.Mesh(new THREE.BoxGeometry(1.0,.18,1.0), main); seat.position.set(0,.62,-.1);
    const hood =new THREE.Mesh(new THREE.BoxGeometry(.8,.22,.7),  main); hood.position.set(0,.58,.6);
    const wG=new THREE.TorusGeometry(.36,.08,10,20), wM=dark;
    const wF=new THREE.Mesh(wG,wM); wF.rotation.x=Math.PI/2; wF.position.set(0,.38,.95);
    const wR=wF.clone(); wR.position.z=-.95; wR.scale.set(1.03,1.03,1.03);
    const bar=new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.65,8), light); bar.rotation.z=Math.PI/2; bar.position.set(0,.92,.45);
    const plate=new THREE.Mesh(new THREE.BoxGeometry(.52,.42,.08), light); plate.position.set(0,.85,.85);
    const fender=new THREE.Mesh(new THREE.BoxGeometry(.9,.08,.5), main); fender.position.set(0,.52,.95);
    const tail=new THREE.Mesh(new THREE.BoxGeometry(.9,.06,.5), main); tail.position.set(0,.52,-.95);
    root.add(frame,seat,hood,wF,wR,bar,plate,fender,tail);
    root.position.y=0.2;
    return root;
  }

  /* ---------- player ---------- */
  const player = makeVehicle(0.02);
  const motoPlayer = makeMotoMesh(0x4caf50); scene.add(motoPlayer);

  /* ---------- input ---------- */
  const input={steer:0, throttle:0, brake:0, hand:false, nitro:false, paused:false};
  const keys={};
  const setKey=(e,d)=>{ const k=e.code||e.key; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); keys[k]=d; };

  addEventListener('keydown',e=>{ setKey(e,true);
    if(e.code==='KeyP'){ input.paused=!input.paused; document.getElementById('pause').style.display=input.paused?'block':'none'; }
    if(e.code==='KeyR'){ resetOnTrack(player.chassis); }
  },{passive:false});
  addEventListener('keyup',e=>setKey(e,false),{passive:false});
  renderer.domElement.addEventListener('click',()=>renderer.domElement.focus());
  renderer.domElement.focus();

  // pads
  function bindPad(pad,stick,cb){
    let act=false,id=null,cx=0,cy=0,r=0;
    const rect=()=>pad.getBoundingClientRect();
    const pos=t=>({x:t.clientX-rect().left,y:t.clientY-rect().top});
    const start=t=>{ if(act)return; act=true; id=t.pointerId; pad.setPointerCapture(id);
      const rc=rect(); cx=rc.width/2; cy=rc.height/2; r=rc.width/2; move(t); };
    const move=t=>{ if(!act||t.pointerId!==id) return; const p=pos(t); let dx=p.x-cx,dy=p.y-cy;
      const m=Math.hypot(dx,dy); if(m>r){dx*=r/m;dy*=r/m;}
      stick.style.left=(50+dx/r*50)+'%'; stick.style.top=(50+dy/r*50)+'%'; cb(dx/r,dy/r); t.preventDefault(); };
    const end =t=>{ if(!act||t.pointerId!==id) return; act=false; try{pad.releasePointerCapture(id)}catch{}
      stick.style.left='50%'; stick.style.top='50%'; cb(0,0); };
    pad.addEventListener('pointerdown',start,{passive:false});
    pad.addEventListener('pointermove', move,{passive:false});
    pad.addEventListener('pointerup',   end ,{passive:false});
    pad.addEventListener('pointercancel',end);
  }
  bindPad(document.getElementById('padL'), document.getElementById('stickL'),
    (dx,dy)=>{ input.steer = clamp(dx,-1,1); });
  bindPad(document.getElementById('padR'), document.getElementById('stickR'),
    (dx,dy)=>{ input.throttle = clamp(-dy,0,1); input.brake = clamp(dy>0?dy:0,0,1); });

  function resetOnTrack(body){
    const p=body.position; let bestD=Infinity,bestT=0;
    const STEPS=360;
    for(let i=0;i<=STEPS;i++){
      const t=i/STEPS, c=track.curve.getPointAt(t);
      const d=(c.x-p.x)**2 + (c.z-p.z)**2; if(d<bestD){bestD=d; bestT=t;}
    }
    const c=track.curve.getPointAt(bestT), tan=track.curve.getTangentAt(bestT);
    const yaw=Math.atan2(tan.x,tan.z);
    body.position.set(c.x, .9, c.z);
    body.velocity.set(0,0,0); body.angularVelocity.set(0,0,0);
    body.quaternion.setFromEuler(0,yaw,0,'XYZ');
  }

  /* ---------- HUD + camera ---------- */
  const spdEl=document.getElementById('spd'), timeEl=document.getElementById('time');
  const startTime=performance.now();
  function chase(mesh){
    const fwd=new THREE.Vector3(0,0,1).applyQuaternion(mesh.quaternion);
    const up =new THREE.Vector3(0,1,0);
    const look=mesh.position.clone().add(fwd.clone().multiplyScalar(4)).add(up.clone().multiplyScalar(1.6));
    const pos =mesh.position.clone().add(fwd.clone().multiplyScalar(-10)).add(up.clone().multiplyScalar(3.8));
    camera.position.lerp(pos,.12); camera.lookAt(look);
  }

  /* ---------- loop ---------- */
  let last=performance.now();
  function tick(now){
    requestAnimationFrame(tick);
    const dt=Math.min(1/60,(now-last)/1000); last=now;
    if(input.paused){ renderer.render(scene,camera); return; }

    // clavier → input (pads gardent leur valeur)
    const up = !!(keys['ArrowUp'] || keys['KeyW'] || keys['KeyZ']);
    const dn = !!(keys['ArrowDown'] || keys['KeyS']);
    const lf = !!(keys['ArrowLeft'] || keys['KeyA'] || keys['KeyQ']);
    const rt = !!(keys['ArrowRight'] || keys['KeyD']);
    if(up) input.throttle=1; if(dn) input.brake=1;
    input.steer += (((lf?-1:0)+(rt?1:0)) - input.steer) * 0.25;
    input.hand = !!keys['Space'];
    input.nitro = !!keys['KeyN'];

    const MAX_ENGINE = input.nitro ? 2800 : 2000;
    const MAX_STEER  = 0.52;
    const BRAKE      = 52, H_BRAKE = 90;

    // grip/adhérence
    const pos=player.chassis.position;
    const {lat}=track.lateralInfo(pos.x,pos.z);
    const onTrack=Math.abs(lat)<=track.ROAD_HALF*1.05;
    const grip=onTrack?1:0.6;

    // steer avant (0,1)
    const steerVal=clamp(input.steer,-1,1)*MAX_STEER*grip;
    player.vehicle.setSteeringValue(steerVal,0);
    player.vehicle.setSteeringValue(steerVal,1);
    // moteur arrière (2,3) — NEGATIVE force = forward ici
    const engine=(input.throttle*MAX_ENGINE)*(onTrack?1:0.6);
    player.vehicle.applyEngineForce(-engine,2);
    player.vehicle.applyEngineForce(-engine,3);
    // frein sur tout
    const brake=(input.brake?BRAKE:0)+(input.hand?H_BRAKE:0);
    for(let i=0;i<4;i++) player.vehicle.setBrake(brake,i);

    world.step(1/60,dt);

    // visuel + HUD + cam
    motoPlayer.position.copy(player.chassis.position);
    motoPlayer.quaternion.copy(player.chassis.quaternion);
    chase(motoPlayer);
    spdEl.textContent=Math.round(player.chassis.velocity.length()*3.6);
    timeEl.textContent=fmt(now-startTime);

    renderer.render(scene,camera);

    // relâche progressif si pas de touche
    if(!up) input.throttle*=0.98;
    if(!dn) input.brake*=0.98;
  }
  requestAnimationFrame(tick);

  addEventListener('resize',()=>{
    renderer.setSize(innerWidth,innerHeight);
    camera.aspect=innerWidth/innerHeight;
    camera.updateProjectionMatrix();
  });
  </script>
</body>
</html>
