<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moto Proto V0</title>
<style>
  html,body{margin:0;height:100%;background:#0b0e14;color:#e8ecf1;font-family:system-ui,Segoe UI,Roboto,Arial;}
  #hud{position:fixed;left:12px;top:12px;line-height:1.25;background:rgba(0,0,0,.35);padding:8px 10px;border-radius:8px;backdrop-filter: blur(4px)}
  #hud b{color:#9be870}
  #tips{position:fixed;right:12px;top:12px;opacity:.8}
  #canvas{display:block;width:100vw;height:100vh}
  #pause{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);font-size:28px;
         padding:14px 18px;background:rgba(0,0,0,.55);border-radius:12px;display:none}
  /* Mobile touch pads */
  .pad{position:fixed;bottom:24px;width:42vw;max-width:340px;height:42vw;max-height:340px;
       border:2px solid rgba(255,255,255,.25);border-radius:50%;opacity:.25}
  #padL{left:24px} #padR{right:24px}
  .stick{position:absolute;left:50%;top:50%;width:30%;height:30%;transform:translate(-50%,-50%);
         border:2px solid rgba(255,255,255,.5);border-radius:50%}
  @media (pointer:fine){ .pad{display:none} }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="hud">
  Vitesse: <b id="spd">0</b> km/h<br/>
  Tour: <b id="lap">0</b> / 3<br/>
  Temps: <b id="time">00:00.000</b><br/>
  Meilleur: <b id="best">--:--.---</b>
</div>
<div id="tips">Clavier: ↑↓ accél./frein, ←→ direction · Espace=frein main · P=Pause</div>
<div id="pause">⏸️ Pause — P pour reprendre</div>
<div id="padL" class="pad"><div class="stick" id="stickL"></div></div>
<div id="padR" class="pad"><div class="stick" id="stickR"></div></div>
<script>
(() => {
  const cvs = document.getElementById('canvas');
  const ctx = cvs.getContext('2d');
  let W=0,H=0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function resize(){
    W = Math.floor(window.innerWidth*DPR);
    H = Math.floor(window.innerHeight*DPR);
    cvs.width = W; cvs.height = H;
    cvs.style.width = (W/DPR|0)+'px';
    cvs.style.height = (H/DPR|0)+'px';
  }
  window.addEventListener('resize', resize,{passive:true}); resize();

  // ---------- Track generation (closed polyline → thick road) ----------
  // A smooth lemniscate-ish layout
  const trackPts = (() => {
    const pts = [];
    const cx=0, cy=0;
    for(let a=0;a<Math.PI*2;a+=Math.PI/48){
      const r = 260 + 120*Math.sin(2*a);
      pts.push({x:cx + r*Math.cos(a), y:cy + r*Math.sin(a*1.07)});
    }
    // Slight perturbations to make it interesting
    return pts.map((p,i)=>({x:p.x + 30*Math.sin(i*0.7), y:p.y + 22*Math.cos(i*0.53)}));
  })();
  const ROAD_W = 70; // half-width in world units
  const OFF_W  = ROAD_W*1.35;

  // Precompute checkpoints every N points (for lap logic)
  const CP_EVERY = 14;
  const checkpoints = trackPts.filter((_,i)=> i%CP_EVERY===0).map((p,i)=>{
    // normal vector for direction test
    const p1 = trackPts[(i*CP_EVERY+1)%trackPts.length];
    const dir = norm({x:p1.x-p.x, y:p1.y-p.y});
    const n = {x:-dir.y,y:dir.x};
    return {x:p.x,y:p.y,n};
  });

  // ---------- World <-> Screen ----------
  let cam = {x: trackPts[0].x, y: trackPts[0].y, rot: 0, zoom: 1.2};
  function worldToScreen(x,y){
    // camera transform: translate, rotate, scale to screen center
    const s = Math.sin(-cam.rot), c = Math.cos(-cam.rot);
    const dx = (x - cam.x), dy = (y - cam.y);
    const rx = dx*c - dy*s;
    const ry = dx*s + dy*c;
    const u = W/2 + rx*cam.zoom;
    const v = H/2 + ry*cam.zoom;
    return {x:u,y:v};
  }

  // ---------- Utility ----------
  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
  function norm(v){ const m=Math.hypot(v.x,v.y)||1; return {x:v.x/m,y:v.y/m}; }
  function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function distToSeg(p,a,b){
    // squared distance from point p to segment ab
    const abx=b.x-a.x, aby=b.y-a.y;
    const t = clamp(((p.x-a.x)*abx+(p.y-a.y)*aby)/(abx*abx+aby*aby),0,1);
    const x = a.x + t*abx, y = a.y + t*aby;
    return {d: Math.hypot(p.x-x,p.y-y), t, x, y};
  }
  function onTrack(p, w=ROAD_W){
    // quick check using nearest segment
    let best = {d:1e9};
    for(let i=0;i<trackPts.length;i++){
      const a = trackPts[i], b = trackPts[(i+1)%trackPts.length];
      const r = distToSeg(p,a,b);
      if(r.d<best.d) best = r;
    }
    return best.d <= w;
  }

  // ---------- Bike physics (bicycle model, arcade tuned) ----------
  const bike = {
    x: trackPts[0].x, y: trackPts[0].y, heading: 0,
    v: 0, // forward m/s
    steer: 0, // -1..1
    angVel: 0,
    targetLean: 0, lean: 0,
    laps: 0, nextCP: 0, lapStart: performance.now(), best: null,
  };

  // Inputs
  const input = {throttle:0, brake:0, steer:0, handbrake:false, gamepad:false};
  // Keyboard
  const keys = {};
  window.addEventListener('keydown', e=>{
    keys[e.code]=true;
    if(e.code==='KeyP'){ togglePause(); }
    if(e.code==='Space'){ input.handbrake=true; }
  });
  window.addEventListener('keyup', e=>{
    keys[e.code]=false;
    if(e.code==='Space'){ input.handbrake=false; }
  });

  // Touch pads (mobile)
  const padL = document.getElementById('padL'), stickL = document.getElementById('stickL');
  const padR = document.getElementById('padR'), stickR = document.getElementById('stickR');
  function bindPad(pad, stick, cb){
    let active=false, id=null, cx=0, cy=0, r=0;
    function pos(t){ const rect=pad.getBoundingClientRect(); return {x:(t.clientX-rect.left), y:(t.clientY-rect.top)};}
    function start(t){
      if(active) return;
      active=true; id=t.pointerId; pad.setPointerCapture(id);
      const rect=pad.getBoundingClientRect(); cx=rect.width/2; cy=rect.height/2; r=rect.width/2;
      move(t);
    }
    function move(t){
      if(!active||t.pointerId!==id) return;
      const p=pos(t); let dx=p.x-cx, dy=p.y-cy;
      const m=Math.hypot(dx,dy); if(m>r){ dx*=r/m; dy*=r/m; }
      stick.style.left=(50+dx/r*50)+'%'; stick.style.top=(50+dy/r*50)+'%';
      cb(dx/r, dy/r);
    }
    function end(t){
      if(!active||t.pointerId!==id) return;
      active=false; try{pad.releasePointerCapture(id);}catch{}
      stick.style.left='50%'; stick.style.top='50%';
      cb(0,0);
    }
    pad.addEventListener('pointerdown', start);
    pad.addEventListener('pointermove', move);
    pad.addEventListener('pointerup', end);
    pad.addEventListener('pointercancel', end);
  }
  bindPad(padL, stickL, (dx,dy)=>{ input.steer = clamp(dx, -1, 1); });
  bindPad(padR, stickR, (dx,dy)=>{ input.throttle = clamp(-dy, 0, 1); input.brake = clamp(dy>0?dy:0, 0, 1); });

  // Gamepad polling
  function pollGamepad(){
    const pads = navigator.getGamepads?.()||[];
    const gp = pads.find(g=>g && g.connected);
    input.gamepad = !!gp;
    if(!gp) return;
    // Left stick X = steer, RT throttle, LT brake, A handbrake
    input.steer = clamp(gp.axes[0]||0, -1, 1);
    input.throttle = clamp((gp.buttons[7]?.value)||0, 0, 1);
    input.brake = clamp((gp.buttons[6]?.value)||0, 0, 1);
    input.handbrake = !!(gp.buttons[0]?.pressed);
  }

  // Pause
  let paused=false;
  const pauseEl = document.getElementById('pause');
  function togglePause(){ paused=!paused; pauseEl.style.display = paused?'block':'none'; }

  // ---------- Update loop ----------
  let last = performance.now();
  function step(now){
    requestAnimationFrame(step);
    if(paused) return;
    const dt = Math.min(0.033, (now-last)/1000); last = now;

    // Inputs from keyboard
    pollGamepad();
    const up=keys['ArrowUp']||keys['KeyW'], dn=keys['ArrowDown']||keys['KeyS'];
    const lf=keys['ArrowLeft']||keys['KeyA'], rt=keys['ArrowRight']||keys['KeyD'];
    input.throttle = Math.max(input.throttle, up?1:0);
    input.brake = Math.max(input.brake, dn?1:0);
    input.steer = clamp(input.steer + ((lf?-1:0)+(rt?1:0) - input.steer)*0.2, -1, 1);
    input.handbrake = input.handbrake || !!keys['Space'];

    // Physics params (arcade tuned)
    const MAX_SPEED = 60; // m/s (~216 km/h)
    const ACCEL = 18;     // m/s^2
    const BRAKE = 28;     // m/s^2
    const HBRAKE = 40;    // m/s^2 (locks rear → drift)
    const STEER_RATE = 2.2; // rad/s at full lock
    const DRAG = 0.18;    // aero drag
    const ROLL = 0.8;     // rolling resistance
    const LATERAL_GRIP = 7.5; // higher → sticks more
    const OFF_GRIP = 0.45;    // grip multiplier off-road
    const OFF_DRAG = 0.8;

    const onRoad = onTrack({x:bike.x, y:bike.y}, OFF_W);
    const deepRoad = onTrack({x:bike.x, y:bike.y}, ROAD_W);
    const gripMul = deepRoad? 1 : (onRoad? 0.6 : OFF_GRIP);
    const dragMul = deepRoad? 1 : (onRoad? 1.3 : OFF_DRAG);

    // Longitudinal
    const aLong = input.throttle*ACCEL - input.brake*BRAKE - (bike.v*DRAG + ROLL)*dragMul
                  - (input.handbrake?HBRAKE:0)*(bike.v>2?1:0)*0.7;
    bike.v += aLong*dt;
    bike.v = clamp(bike.v, -12, MAX_SPEED);

    // Steering / heading using bicycle/slip approximation
    const steerMax = 0.9; // rad
    bike.steer = clamp(input.steer, -1, 1) * steerMax * gripMul;
    const yawRate = (bike.v) * Math.tan(bike.steer) * 0.9 / 3.0; // wheelbase ~3
    const slip = (bike.v) * Math.sin(bike.steer) / Math.max(1, LATERAL_GRIP*gripMul);
    bike.heading += (yawRate - slip*0.35)*dt;

    // Integrate position
    bike.x += Math.cos(bike.heading)*bike.v*dt;
    bike.y += Math.sin(bike.heading)*bike.v*dt;

    // Visual lean (banking)
    bike.targetLean = clamp(bike.v*0.02 * (input.steer), -0.7, 0.7);
    bike.lean += (bike.targetLean - bike.lean)*Math.min(1, dt*6);

    // Soft reset if you go far off
    if(!onRoad && Math.abs(bike.v)<2){
      // nudge back towards nearest segment center
      let best = {d:1e9, x:bike.x, y:bike.y};
      for(let i=0;i<trackPts.length;i++){
        const a=trackPts[i], b=trackPts[(i+1)%trackPts.length];
        const r=distToSeg({x:bike.x,y:bike.y}, a, b);
        if(r.d<best.d) best=r;
      }
      const toCenter = norm({x:best.x-bike.x, y:best.y-bike.y});
      bike.x += toCenter.x*8*dt;
      bike.y += toCenter.y*8*dt;
      bike.v *= 0.98;
    }

    // Checkpoints & laps
    const cp = checkpoints[bike.nextCP];
    if(cp){
      const v = {x:bike.x-cp.x, y:bike.y-cp.y};
      const pass = (Math.abs(v.x*cp.n.x + v.y*cp.n.y) < ROAD_W*0.8) && dist({x:bike.x,y:bike.y}, cp) < ROAD_W*1.2;
      if(pass){
        bike.nextCP++;
        if(bike.nextCP>=checkpoints.length){
          bike.nextCP=0; bike.laps++;
          const nowLap = now - bike.lapStart;
          if(!bike.best || nowLap < bike.best) bike.best = nowLap;
          bike.lapStart = now;
        }
      }
    }

    // Camera follow with small lead
    const look = {x:bike.x + Math.cos(bike.heading)*50, y:bike.y + Math.sin(bike.heading)*50};
    cam.x += (look.x - cam.x)*dt*2.2;
    cam.y += (look.y - cam.y)*dt*2.2;
    cam.rot += (bike.heading - cam.rot)*dt*1.8;
    cam.zoom += ((DPR>1?1.4:1.2) - cam.zoom)*dt;

    draw(now);
    updateHUD(now);
  }
  requestAnimationFrame(step);

  // ---------- Rendering ----------
  function draw(now){
    ctx.clearRect(0,0,W,H);

    // Background grid/grass
    ctx.save();
    ctx.fillStyle = '#0e141b';
    ctx.fillRect(0,0,W,H);
    // World → Screen tiling
    ctx.globalAlpha = .55;
    for(let i=-2000;i<=2000;i+=80){
      const a=worldToScreen(i,-2000), b=worldToScreen(i,2000);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
      ctx.lineWidth=1; ctx.strokeStyle='#141b25'; ctx.stroke();
      const c=worldToScreen(-2000,i), d=worldToScreen(2000,i);
      ctx.beginPath(); ctx.moveTo(c.x,c.y); ctx.lineTo(d.x,d.y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.restore();

    // Road (draw thick polyline twice: shoulder then asphalt)
    function drawPolyline(points, width, color){
      ctx.save();
      ctx.lineCap='round'; ctx.lineJoin='round';
      ctx.strokeStyle=color; ctx.lineWidth=width*cam.zoom;
      ctx.beginPath();
      const p0=worldToScreen(points[0].x,points[0].y);
      ctx.moveTo(p0.x,p0.y);
      for(let i=1;i<points.length;i++){
        const p=worldToScreen(points[i].x,points[i].y);
        ctx.lineTo(p.x,p.y);
      }
      // close loop
      const pN=worldToScreen(points[0].x,points[0].y);
      ctx.lineTo(pN.x,pN.y);
      ctx.stroke();
      ctx.restore();
    }
    drawPolyline(trackPts, (ROAD_W*2.6), '#293241'); // shoulder
    drawPolyline(trackPts, (ROAD_W*2.0), '#3a475a'); // asphalt

    // Center dashed line
    ctx.save();
    ctx.setLineDash([16*cam.zoom,12*cam.zoom]);
    drawPolyline(trackPts, 2.2, '#b7c9ff');
    ctx.restore();

    // Checkpoints
    for(let i=0;i<checkpoints.length;i++){
      const cp=checkpoints[i];
      const a=worldToScreen(cp.x-ROAD_W*cp.n.x, cp.y-ROAD_W*cp.n.y);
      const b=worldToScreen(cp.x+ROAD_W*cp.n.x, cp.y+ROAD_W*cp.n.y);
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
      ctx.lineWidth=3*cam.zoom;
      ctx.strokeStyle = (i===bike.nextCP)?'#9be870':'#6b7280';
      ctx.stroke();
    }

    // Bike
    const p = worldToScreen(bike.x,bike.y);
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate(bike.heading - cam.rot); // orientation relative to camera
    ctx.rotate(bike.lean*0.25); // slight screen-space lean
    const L=26*cam.zoom, Wd=10*cam.zoom;
    // shadow
    ctx.globalAlpha=.25;
    ctx.beginPath(); ctx.ellipse(0, 8*cam.zoom, L, Wd*1.2, 0, 0, Math.PI*2);
    ctx.fillStyle='#000'; ctx.fill();
    ctx.globalAlpha=1;
    // body
    ctx.fillStyle = '#f5f6f8';
    ctx.fillRect(-L*0.5,-Wd*0.5, L, Wd);
    // accents
    ctx.fillStyle = '#7cdfff';
    ctx.fillRect(-L*0.1,-Wd*0.6, L*0.4, Wd*0.2);
    ctx.fillStyle = '#ff8aa0';
    ctx.fillRect(L*0.15, -Wd*0.55, L*0.3, Wd*0.2);
    // rider helmet
    ctx.beginPath(); ctx.arc(-L*0.35,0, Wd*0.6, 0, Math.PI*2);
    ctx.fillStyle='#222'; ctx.fill();
    ctx.restore();

    // Minimap
    const mmScale = 0.25, mmW = 220*DPR, mmH = 160*DPR;
    ctx.save();
    ctx.translate(W-mmW-20*DPR, H-mmH-20*DPR);
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,mmW,mmH);
    ctx.translate(mmW/2, mmH/2);
    ctx.scale(mmScale, mmScale);
    ctx.strokeStyle='#5a6577'; ctx.lineWidth=8; ctx.lineCap='round';
    ctx.beginPath();
    for(let i=0;i<trackPts.length;i++){
      const p = trackPts[i];
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.closePath(); ctx.stroke();
    // bike on minimap
    ctx.fillStyle='#9be870';
    ctx.beginPath(); ctx.arc(bike.x, bike.y, 10, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // ---------- HUD ----------
  const spdEl = document.getElementById('spd');
  const lapEl = document.getElementById('lap');
  const timeEl = document.getElementById('time');
  const bestEl = document.getElementById('best');
  const fmt = ms => {
    if(ms==null) return '--:--.---';
    const m = Math.floor(ms/60000); ms-=m*60000;
    const s = Math.floor(ms/1000); const r = Math.floor(ms%1000);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}.${String(r).padStart(3,'0')}`;
  };
  function updateHUD(now){
    spdEl.textContent = Math.round(Math.max(0,bike.v)*3.6);
    lapEl.textContent = `${Math.min(bike.laps,3)}`;
    timeEl.textContent = fmt(now - bike.lapStart);
    bestEl.textContent = fmt(bike.best);
  }

  // Start a 3-lap run (if you veux un “finish”, on peut arrêter à 3)
})();
</script>
</body>
</html>
